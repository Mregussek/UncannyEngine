#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_GOOGLE_include_directive : enable

#include "DataTypes.glsl"
#include "Random.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, rgba32f) uniform image2D outputImage;
layout(binding = 2, set = 0) uniform PerFrameUniformData_ { PerFrameUniformData d; } perFrameData;

layout(location = 0) rayPayloadEXT HitPayload hitPayload;

void main() {
    vec3 pixelColorValue = vec3(0.f);
    uint maxSamplesPerPixel = perFrameData.d.maxSamplesPerPixel;
    uint maxRayBouncesCount = perFrameData.d.maxRayBounces;
    uint pixelRandomSeed = perFrameData.d.randomSeed;

    const vec4 origin = perFrameData.d.viewInverse * vec4(0.f, 0.f, 0.f, 1.f);

    for (uint s = 0; s < maxSamplesPerPixel; s++)
    {
        hitPayload.raySeed = InitRandomSeed(InitRandomSeed(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y), pixelRandomSeed);

        const vec2 pixelSample = gl_LaunchIDEXT.xy + vec2(RandomFloat(pixelRandomSeed), RandomFloat(pixelRandomSeed));
        const vec2 launchSizeScale = vec2(1.f, 1.f) / gl_LaunchSizeEXT.xy;
        const vec2 uv = pixelSample * launchSizeScale * 2.f - 1.f;

        const vec4 target = perFrameData.d.projInverse * vec4(uv.xy, 1.f, 1.f) ;
        const vec4 direction = perFrameData.d.viewInverse * vec4(normalize(target.xyz), 0.f) ;

        hitPayload.rayOrigin = origin.xyz;
        hitPayload.rayDirection = direction.xyz;

        vec3 rayColorValue = vec3(1);
        for (int b = 0; b < maxRayBouncesCount; b++)
        {
            traceRayEXT(topLevelAS,             // accelerationStructureEXT topLevel
                        gl_RayFlagsOpaqueEXT,   // rayFlags
                        0xff,                   // cullMask
                        0,                      // sbtRecordOffset
                        0,                      // sbtRecordStride
                        0,                      // missIndex
                        hitPayload.rayOrigin,   // origin
                        0.001f,                 // Tmin
                        hitPayload.rayDirection,// direction
                        10000.0f,               // Tmax
                        0                       // payload
            );
            rayColorValue *= hitPayload.directColor;

            // Trace missed, or end of trace.
            if (hitPayload.t < 0 || !hitPayload.isScattered)
            {
                break;
            }
        }
        pixelColorValue += rayColorValue;
    }

    // Divide the color by number of samples
    float samplesScale = 1.f / float(maxSamplesPerPixel);
    pixelColorValue = vec3(pixelColorValue) * samplesScale;

    // Gamma Correction
    pixelColorValue = sqrt(pixelColorValue);
    pixelColorValue = clamp(pixelColorValue, 0.f, 0.999f);

    // Add accumulated pixel color
    vec4 accumulatedColor = imageLoad(outputImage, ivec2(gl_LaunchIDEXT.xy));
    accumulatedColor *= perFrameData.d.notMovingCameraFrameCount;

    pixelColorValue += vec3(accumulatedColor);
    float frameScale = 1.f / float(perFrameData.d.notMovingCameraFrameCount + 1);
    pixelColorValue *= frameScale;

    imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), vec4(pixelColorValue, 1.0));
}
