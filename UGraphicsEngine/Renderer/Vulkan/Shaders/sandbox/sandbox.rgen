#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_GOOGLE_include_directive : enable

#include "../DataTypes.glsl"
#include "../Random.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, rgba32f) uniform image2D outputImage;
layout(binding = 2, set = 0) uniform PerFrameUniformData_ { PerFrameUniformData d; } perFrameData;

layout(location = 0) rayPayloadEXT HitPayload hitPayload;

void main() {
    vec3 pixelColorValue = vec3(0.f);
    uint maxSamplesPerPixel = perFrameData.d.maxSamplesPerPixel;
    uint maxRayBouncesCount = perFrameData.d.maxRayBounces;
    uint pixelRandomSeed = perFrameData.d.randomSeed;

    const vec4 origin = perFrameData.d.viewInverse * vec4(0.f, 0.f, 0.f, 1.f);

    for (uint s = 0; s < maxSamplesPerPixel; s++)
    {
        // Calculating initial ray direction...
        const vec2 pixelSample = gl_LaunchIDEXT.xy + vec2(RandomFloat(pixelRandomSeed), RandomFloat(pixelRandomSeed));
        const vec2 launchSizeScale = vec2(1.f, 1.f) / gl_LaunchSizeEXT.xy;
        const vec2 uv = pixelSample * launchSizeScale * 2.f - 1.f;
        const vec4 target = perFrameData.d.projInverse * vec4(uv.xy, 1.f, 1.f) ;
        const vec4 direction = perFrameData.d.viewInverse * vec4(normalize(target.xyz), 0.f) ;

        // Initial hit payload setup...
        hitPayload.raySeed = InitRandomSeed(InitRandomSeed(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y), pixelRandomSeed);
        hitPayload.rayOrigin = origin.xyz;
        hitPayload.rayDirection = direction.xyz;

        vec3 rayColorValue = vec3(1);
        for (int b = 1; b < (maxRayBouncesCount + 1); b++) // iterating from 1, as ray depth may be used as divisor
        {
            hitPayload.rayDepth = b;
            traceRayEXT(topLevelAS,             // accelerationStructureEXT topLevel
                        gl_RayFlagsOpaqueEXT,   // rayFlags
                        0xff,                   // cullMask
                        0,                      // sbtRecordOffset
                        0,                      // sbtRecordStride
                        0,                      // missIndex
                        hitPayload.rayOrigin,   // origin
                        0.001f,                 // Tmin
                        hitPayload.rayDirection,// direction
                        10000.0f,               // Tmax
                        0                       // payload
            );
            rayColorValue *= (hitPayload.directColor + hitPayload.indirectColor);

            const bool traceMissed = hitPayload.t < 0;
            const bool endOfTrace = !hitPayload.isScattered;
            if (traceMissed || endOfTrace)
            {
                break;
            }
        }
        pixelColorValue += rayColorValue;
    }

    // Divide the color by number of samples
    {
        const float samplesScale = 1.f / float(maxSamplesPerPixel);
        pixelColorValue = vec3(pixelColorValue) * samplesScale;
    }

    // Gamma Correction
    pixelColorValue = sqrt(pixelColorValue);
    pixelColorValue = clamp(pixelColorValue, 0.f, 0.999f);

    // Add accumulated pixel color
    if (perFrameData.d.accumulatePreviousColors > 0)
    {
        const vec4 accumulatedColor =
            imageLoad(outputImage, ivec2(gl_LaunchIDEXT.xy)) * perFrameData.d.notMovingCameraFrameCount;
        const float frameScale = 1.f / float(perFrameData.d.notMovingCameraFrameCount + 1);

        pixelColorValue = (pixelColorValue + vec3(accumulatedColor)) * frameScale;
    }

    imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), vec4(pixelColorValue, 1.0));
}
